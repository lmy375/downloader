package downloader.object;


import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.Serializable;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;

import javax.swing.JOptionPane;

/**
 * Major class about downloading which describe the Task block.
 * Function runs in individual thread. 
 * Implementing Serializable interface. 
 * @author Moon
 *
 */
public class Task implements Runnable ,Serializable{

	private static final long serialVersionUID = -369252014752930218L;
	private URL url;
	private String fileName;
	private String filePath;
	//private RandomAccessFile file;

	
	private int fileSize= 0 ;
	private int threadCount= 0 ;

	private ArrayList<DownloadThread> threads;

	private int downloadStatus;

	private final int BUFFER_SIZE = 1024*16;
	public final static int PREPARING = 10;
	public final static int DOWNLOADING = 11;
	public final static int PAUSED = 12;
	public final static int MERGING = 13;
	public final static int FINISHED = 14;
	public final static int STOPPED = 15;
	

//	private Thread timer;
	private int timeUsed= 0 ;
	/**
	 * True when error occurs.
	 */
	private boolean error = false;
	/**
	 * Tests whether error occurs.
	 * @return true when error occurs.
	 */
	public boolean isError(){
		return this.error;
	}
	/**
	 * Sets error true.
	 */
	public void setError(){
		this.error = true;
	}
	/**
	 * Sets error false.
	 */
	public void clearError(){
		this.error = false;
	}

	/**
	 * Constructor of task.
	 * @param url HTTP_URL of file from Internet
	 * @param fileName File name user saves the file. 
	 * @param filePath File path user saves the file.
	 * @param threadCount Thread count set by user (ranges :1~ 16).
	 * @throws IOException
	 */
	public Task(String url, String fileName, String filePath, int threadCount) throws IOException {

		//try {
			
		   // new Thread(this).start();
		    
			this.downloadStatus = Task.PREPARING;
			this.url = new URL(url);
			this.fileName= fileName;
			this.filePath = filePath;
			// this.file= new RandomAccessFile(file, "rwd");
			this.threadCount = threadCount;
			HttpURLConnection conn;
			conn = (HttpURLConnection) this.url.openConnection();
			this.fileSize = conn.getContentLength();

			this.threads = new ArrayList<DownloadThread>();
			
			
			//this.timer = new Thread(this);
			
		/*}catch (MalformedURLException mue) {
			JOptionPane.showMessageDialog(null, "URL Error" + mue.getMessage());
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}*/

		

	}

	/**
	 * Start Downloading which equals to set threads.
	 */
	public void beginDownload() {
		this.downloadStatus=Task.DOWNLOADING;
		this.timeUsed=0;		
		new Thread(this).start();		
		this.setThreads();
		
	}
	
	/**
	 * Establishes threads according to thread count.
	 * And start all threads.
	 */
	private void setThreads() {
		int blockLength = this.fileSize / this.threadCount;
		int i;
		for (i = 1; i < this.threadCount; i++)
			threads.add(new DownloadThread(this, blockLength * (i - 1),
					blockLength * i - 1, i));
		threads.add(new DownloadThread(this, blockLength * (i - 1), this.fileSize-1,
				i));
		for (DownloadThread t : threads) {
			t.startDownload();
		}	
		
	}
	
	/**
	 * Function used after a task is paused.
	 * Start all threads.
	 */
	public void resumeDownload(){
				
		new Thread(this).start();
		//System.out.print("start timer");
		
		for(DownloadThread t:threads){
			//t.run();
			t.startDownload();
		}
		//System.out.print("why....");
	}
	
	/**
	 * Pause this task if task is not paused , else resume.
	 */
	public void pause() {
		if(this.downloadStatus == Task.PAUSED){
			this.downloadStatus=Task.DOWNLOADING;
			
			for (DownloadThread t : threads) {
				t.setPause(false);				
			}
			this.resumeDownload();
			
			
			
		}
		else if(this.downloadStatus==Task.DOWNLOADING){
			this.downloadStatus=Task.PAUSED;
			for (DownloadThread t : threads) {
				t.setPause(true);
			}
			
		}
	}
	/**
	 * Stop the task. Usually caused by unknown connection error.
	 *  Also controlled by user.
	 */
	public void stop(){
		if(this.downloadStatus!=Task.PAUSED) this.pause();
		this.downloadStatus=Task.STOPPED;
	}
	
	/**
	 * Restart the task , especially used on a stopped task.
	 * All unfinished data will be cleared. 
	 */
	public void restart() {
		
			this.stop();
			this.clearData();
			this.beginDownload();						
	}
	/**
	 * Clear all temporary files generated by previous threads.
	 * Then clear threads.
	 */
	public void clearData(){
		for(DownloadThread t:threads){
			File f = new File(t.getFilePath());
			f.delete();				
		}
		threads.clear();		
	}

	/**
	 * Merge all temporary files. If user defines the count of threads as ONE,
	 * rename the .tmp files to the destination file directly. If not ,
	 * establish InputStreams for each file and write all .tmp files to the
	 * destination file and delete all .tmp files after operation.
	 * 
	 */
	public void merge() {

		// System.out.println("Begin to Merge.");

		if (this.threadCount == 1) {
			File f = new File(threads.get(0).getFilePath());
			f.renameTo(new File(this.filePath+"\\"+this.fileName));

		} else {
			RandomAccessFile file=null;

			try {
				file = new RandomAccessFile(filePath+"\\"+this.fileName, "rwd");
			} catch (FileNotFoundException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			this.downloadStatus = Task.MERGING;
			int currentPos = 0;
			for (DownloadThread t : threads) {
				try {
					File f = new File(t.getFilePath());
					FileInputStream fis = new FileInputStream(f);
					byte[] buff = new byte[BUFFER_SIZE];
					int length;
					file.seek(currentPos);
					while ((length = fis.read(buff)) != -1) {
						file.write(buff, 0, length);
						currentPos += length;
					}
					fis.close();					
					//f.delete();

					// System.out.println("Delete"+ t.getFilePath()+f.delete());

					// System.out.println("Merges Thread"+t.getThreadID());
				} catch (FileNotFoundException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			for (DownloadThread t : threads) {				
					File f = new File(t.getFilePath());									
					f.delete();			
					// System.out.println("Delete"+ t.getFilePath()+f.delete());
					// System.out.println("Merges Thread"+t.getThreadID());				
			}
			
			

			try {
				file.close();
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			// System.out.println("Merged");
		}
		this.downloadStatus = Task.FINISHED;

	}
	

	/*
	 * method to print all element for test.
	 *
	 *
	 * public void test(){ System.out.println("File size:"+this.size);
	 * System.out.println("File thread count:"+ this.threadCount);
	 * System.out.println("File path:"+this.filePath);
	 * System.out.println("File URL:"+ this.url.toString());
	 * System.out.println("File download state"+ this.downloadState);
	 * 
	 * 
	 * }
	 */
	/**
	 * Tests whether task is ready to merge which equals all threads are finished
	 * @return true if task is ready 
	 */
	public boolean isReadyToMerge() {
		for (DownloadThread t : this.threads) {
			if (!t.isFinished())
				return false;
		}
		// System.out.println("Ready to Merge.");
		return true;
	}

	/**
	 * Gets URL.
	 * 
	 * @return URL
	 */
	public URL getURL() {
		return this.url;
	}

	/**
	 * Gets file name which is taken from the tail of file path.
	 * 
	 * @return file name.
	 */
	public String getFileName() {
		return this.fileName;
	}
	
	/**
	 * Gets file path of the task.
	 * @return file path.
	 */
	public String getFilePath(){
		return this.filePath;
	}
	/**
	 * Gets size of the task
	 * 
	 * @return size of file
	 */
	public int getFileSize() {
		return this.fileSize;
	}

	/**
	 * Gets size of finished data
	 * 
	 * @return finished size
	 */
	public int getFinishedSize() {
		int finishedSize = 0;
		for (DownloadThread t : threads) {
			finishedSize += t.getCurrentPos();
		}
		return finishedSize;
	}

	/**
	 * Gets time used for downloading
	 * 
	 * @return time used
	 */
	public int getTimeUsed() {
		return this.timeUsed;
	}
	/**
	 * Gets current status of this task
	 * @return current status
	 */
	public int getCurrentStatus() {
		return this.downloadStatus;
	}

	/**
	 * Running in a single thread as a timer, value grows only if status
	 * of this task is downloading or preparing or merging.
	 */
	public void run() {
		
		while (true) {
			if(this.downloadStatus==Task.FINISHED
					||this.downloadStatus==Task.STOPPED
					||this.downloadStatus==Task.PAUSED)
			break;
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					JOptionPane.showMessageDialog(null,
							"Timer Error" + e.getMessage());
				}
				//System.out.println(timeUsed++);
				
				timeUsed++;

		}
		
	}
	
	

}
